<!DOCTYPE html>
<html>
  <head>
    <script src="../dist/jspsych.js"></script>
    <script src="../dist/plugin-html-keyboard-response.js"></script>
    <script src="../dist/plugin-html-button-response.js"></script>
    <script src="../dist/plugin-webgazer-init-camera.js"></script>
    <script src="../dist/plugin-webgazer-calibrate.js"></script>
    <script src="../dist/plugin-webgazer-validate.js"></script>
    <script src="js/webgazer/webgazer.js"></script>
    <script src="../dist/extension-webgazer.js"></script>
    <script src="../dist/plugin-virtual-chinrest.js"></script>
    <link rel="stylesheet" href="../dist/jspsych.css" />
    
    <style>
      .jspsych-content {
        max-width: 100%;
      }
    </style>
  </head>
  <body></body>
  <script>
    
    
    let timeline = [];
    const accuracyResults = [];
    let pixelsPerDegree = null;  // global variable to store result


    ///////////////////// CAN MODIFY HERE/////////////////////////////////////
    let radiusVisualAngle = 4    // The visual angle that will determine the size of the roi radius

    const calibrationConfigs = [
      { points: 5, reps: 2 },
      { points: 9, reps: 5 },
      { points: 13, reps: 3 },
    ];

    const regressionModels = ['ridge', 'weightedRidge']; 

    ///////////////////////////////////////////////////////////////////////////////////


    var jsPsych = initJsPsych({
      extensions: [
        {
          type: jsPsychExtensionWebgazer,
          params: { targets: [] }  // ‚úÖ Required to avoid target errors
        }
      ]
    });

    
    var camera_instructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <p>This experiment uses your camera for eye tracking.</p>
        <p>In order to participate you must allow the experiment to use your camera.</p>
        <p>You will be prompted to do this on the next screen.</p>
        <p>If you do not want to permit the experiment to use your camera, please close the page.</p>
      `,
      choices: ['Click to begin'],
      post_trial_gap: 1000
    };

    var init_camera = {
      type: jsPsychWebgazerInitCamera
    };


    function getCalibrationPoints(n) {
      if (n === 5) return [[25,25],[75,25],[50,50],[25,75],[75,75]];
      if (n === 9) return [[20,20],[50,20],[80,20],[20,50],[50,50],[80,50],[20,80],[50,80],[80,80]];
      if (n === 13) return [[10,10],[30,10],[50,10],[70,10],[90,10],
                            [20,50],[40,50],[60,50],[80,50],
                            [10,90],[30,90],[50,90],[70,90]];
      return [[50, 50]];
    }






    timeline.push({
      type: jsPsychVirtualChinrest,
      blindspot_reps: 2,
      resize_prompt: true,
      data: { trial_id: 'virtual-chinrest' },
      on_finish: function(data) {
        console.log("üì¶ Chinrest data:", data);

        if (data.px2deg) {
          pixelsPerDegree = data.px2deg;
          data.pixels_per_degree = data.px2deg; // add alias for downstream use/logging
          console.log("üü¢ pixelsPerDegree set from px2deg:", pixelsPerDegree);
        } else {
          pixelsPerDegree = 50;
          console.warn("‚ö†Ô∏è px2deg missing; defaulting to 50");
        }
      }
    });


    // ‚úÖ Initial instructions and camera setup
    // timeline.push(camera_instructions);
    // timeline.push(init_camera);

    // ‚úÖ Loop through all calibration configurations and models
    regressionModels.forEach(model => {
      calibrationConfigs.forEach(cfg => {
        const label = `${cfg.points} points, ${cfg.reps} reps, ${model}`;

        timeline.push({
          type: jsPsychWebgazerInitCamera,
          on_finish: () => {
            webgazer.setRegression(model);  // ‚úÖ Model applied after camera starts
            console.log(`üß† Regression set to: ${model}`);
          }
        });

        
        // üß™ Calibration Trial
        timeline.push({
          type: jsPsychHtmlButtonResponse,
          stimulus: `<p><strong>Starting trial:</strong> ${label}</p>`,
          choices: ['Continue'],
          on_start: () => {
            console.log("‚ñ∂Ô∏è Starting block:", label);
          }
          }
        );

        timeline.push({
          type: jsPsychWebgazerCalibrate,
          calibration_points: getCalibrationPoints(cfg.points),
          repetitions_per_point: cfg.reps,
          randomize_calibration_order: true
        });

        // üß™ Validation Trial
        timeline.push({
          type: jsPsychHtmlButtonResponse,
          stimulus: `<p>Calibration done. Click to begin validation.</p>`,
          choices: ['Validate'],
          post_trial_gap: 500
        });

        timeline.push({
          type: jsPsychWebgazerValidate,
          validation_points: [[50,50]],
          roi_radius: (pixelsPerDegree || 50) * radiusVisualAngle,
          validation_duration: 10000, // 10 seconds just like real experiment
          time_to_saccade: 1000,
          show_validation_data: true,
          on_finish: function(data) {
            console.log("üëÅÔ∏è raw_gaze:", data.raw_gaze);

            const r_values = data?.average_offset?.map(p => p.r);
            const avg = r_values && r_values.length
              ? r_values.reduce((a, b) => a + b, 0) / r_values.length
              : null;

            // % inside ROI
            const allPoints = Array.isArray(data?.raw_gaze?.[0])
              ? data.raw_gaze[0]
              : [];

            console.log("üìå All gaze points collected:", allPoints.length);

            const roiPx = pixelsPerDegree * radiusVisualAngle;
            const inside = allPoints.filter(p => {
              const dx = p.x - window.innerWidth / 2;
              const dy = p.y - window.innerHeight / 2;
              return Math.sqrt(dx * dx + dy * dy) <= roiPx;
            });

            const percentInside = allPoints.length
              ? (inside.length / allPoints.length) * 100
              : null;

            accuracyResults.push({
              label,
              accuracy: avg ? Number(avg.toFixed(2)) : 'N/A',
              percent_inside_roi: percentInside ? Number(percentInside.toFixed(1)) : 'N/A',
              pixels_per_degree: pixelsPerDegree,
              roi_radius_px: roiPx
            });

            console.log("üìä Accuracy result:", {
              label,
              average_px: avg,
              percent_inside_roi: percentInside
            });

            webgazer.clearData();
          }

        });
      });
    });

    // ‚úÖ Final summary screen
    timeline.push({
      type: jsPsychHtmlButtonResponse,
      stimulus: function() {
      let html = `<h3>üìä Final Accuracy Report</h3>
        <table border="1" style="margin:auto;">
          <tr>
            <th>Condition</th>
            <th>Avg Offset (px)</th>
            <th>% in ROI</th>
            <th>PPD</th>
            <th>ROI Radius (px)</th>
          </tr>`;
      accuracyResults.forEach(row => {
        html += `<tr>
          <td>${row.label}</td>
          <td>${row.accuracy}</td>
          <td>${row.percent_inside_roi}</td>
          <td>${row.pixels_per_degree}</td>
          <td>${row.roi_radius_px}</td>
        </tr>`;
      });
      html += '</table><p>Click to finish.</p>';
      return html;
      },
      choices: ['Finish']
    });

    // üöÄ Run the experiment
    jsPsych.run(timeline);

   </script>
</html>
