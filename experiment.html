<!DOCTYPE html>
<html>
    <head>
        <!-- Load jsPsych and plugins -->
        <script src='jspsych/dist/jspsych.js'></script>

        <!-- ✅ Load WebGazer BEFORE any plugins that depend on it -->
        <script src="jspsych/webgazer.js"></script>
        <script src="jspsych/dist/extension-webgazer.js"></script>


        <!-- ✅ Only now load the plugin that uses WebGazer -->
        <script src='jspsych/dist/plugin-webgazer-init-camera.js'></script>
        <script src='jspsych/dist/plugin-webgazer-calibrate.js'></script>
        <script src='jspsych/dist/plugin-webgazer-validate.js'></script>

        <!-- Other jsPsych plugins -->
        <script src='jspsych/dist/plugin-preload.js'></script>
        <script src='jspsych/dist/plugin-html-slider-response.js'></script>
        <script src='jspsych/dist/plugin-html-keyboard-response.js'></script>
        <script src='jspsych/dist/plugin-html-button-response.js'></script>
        <script src='jspsych/dist/plugin-survey-multi-choice.js'></script>
        <script src='jspsych/dist/plugin-survey-text.js'></script>
        <script src='jspsych/dist/plugin-virtual-chinrest.js'></script>
        <script src='jspsych/dist/plugin-fullscreen.js'></script>
        <script src='jspsych/dist/plugin-survey-html-form.js'></script>
        <script src='jspsych/dist/plugin-instructions.js'></script>
        <script src='jspsych/dist/plugin-image-keyboard-response.js'></script>
        <script src="jspsych/dist/plugin-call-function.js"></script>
        <script src='jatos.js'></script>

        <style>
            /* 1. Base page layout — fills screen, prevents scrollbars */
            html, body {
              margin: 0;
              padding: 0;
              height: 100%;
              width: 100%;
              font-family: Arial, sans-serif;
              overflow: hidden;
            }
          
            /* 2. Main jsPsych container — center content horizontally and vertically */
            .jspsych-display-element {
              display: flex !important;
              justify-content: center;
              align-items: center;
              height: 100vh;
              flex-direction: column;
              text-align: center;
            }
          
            /* 3. Prevent jsPsych from narrowing content */
            .jspsych-content {
              max-width: 100% !important;
              text-align: center;
            }
          
            /* 4. Clean form inputs and dropdowns */
            input[type="text"],
            input[type="number"],
            select {
              border: 1px solid #ccc;
              padding: 6px 8px;
              font-size: 16px;
              border-radius: 4px;
              box-sizing: border-box;
              background-color: white;
              width: 250px;
              text-align: center;
            }
          
            /* 5. Keep spacing between form questions clean */
            .jspsych-survey-html-form p {
              margin-bottom: 12px;
            }
          
            /* 6. Style all jsPsych buttons */
            .jspsych-btn {
              margin-top: 20px;
              font-size: 18px;
              padding: 10px 20px;
            }
          
            /* 7. Center individual button responses (e.g., Continue) */
            .jspsych-html-button-response-button {
              margin: 10px auto;
            }
          
            /* 8. Gaze red dot (for real-time debugging) */
            #gaze-dot {
              position: fixed;
              width: 15px;
              height: 15px;
              background-color: red;
              border-radius: 50%;
              z-index: 9999;
              pointer-events: none;
              display: none;
            }


            .jspsych-required-asterisk {
                display: none;
            }

          </style>
          
          
          
    </head>
    <body>
        <div id="gaze-dot" style="display: none;"></div>
    </body>

    <script>
        var jsPsych = initJsPsych({
            extensions: [
                {type: jsPsychExtensionWebgazer}
            ],
            on_finish: () => jatos.endStudy(jsPsych.data.get().json())
        });
 
        ////////////////////////////////////////////////////////////////////////////////////
        // Instructions / pre-exp screens according to the order in the experiment        //
        ////////////////////////////////////////////////////////////////////////////////////
        
        var pixelsPerDegree = 50; // default, will be updated after chinrest
        const imageHeight = 26 * pixelsPerDegree; // choosing the angle that determines the image size
        let calibrationCountThisBlock = 0; // initiating counter for amount of calibrations in each block

        
        // using a virtual chinrest to make the size (in VA) constant across participants //
        var virtual_chinrest = {
            type: jsPsychVirtualChinrest,
            blindspot_reps: 3,
            resize_units: "deg",
            pixels_per_unit: 50,
            item_path: 'stimuli/credit_card.png',
            on_finish: function(data) {
                const maxPPD = window.innerHeight / 26;

                if (data.pixels_per_degree) {
                    const wasClamped = data.pixels_per_degree > maxPPD;
                    data.original_pixels_per_degree = data.pixels_per_degree;
                    data.pixels_per_degree = Math.min(data.pixels_per_degree, maxPPD);
                    data.was_clamped = wasClamped;
                    data.baseline_zoom = detectZoomLevel();
                    pixelsPerDegree = data.pixels_per_degree;
                } else {
                    data.original_pixels_per_degree = 50;
                    data.pixels_per_degree = 50;
                    data.was_clamped = false;
                    data.baseline_zoom = detectZoomLevel();
                    pixelsPerDegree = 50;
                }
            }
        };

        var get_pixels_per_degree = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: "<p>Calibrating image size...</p>",
            choices: "NO_KEYS",
            trial_duration: 100,
            on_start: function() {
                const chinrestData = jsPsych.data.get().filter({ trial_type: 'virtual-chinrest' }).last(1).values()[0];
                if (chinrestData && chinrestData.pixels_per_degree) {
                const proposedPPD = chinrestData.pixels_per_degree;
                const maxPPD = window.innerHeight / 26;
                pixelsPerDegree = Math.min(proposedPPD, maxPPD);

                const wasClamped = proposedPPD > maxPPD;

                jsPsych.data.addProperties({
                    pixels_per_degree: pixelsPerDegree,
                    original_pixels_per_degree: proposedPPD,
                    was_clamped: wasClamped,
                    baseline_zoom: detectZoomLevel()
                });
                } else {
                console.warn("⚠️ No chinrest data found. Using fallback.");
                pixelsPerDegree = 50;
                jsPsych.data.addProperties({
                    pixels_per_degree: 50,
                    was_clamped: false,
                    original_pixels_per_degree: 50,
                    baseline_zoom: detectZoomLevel()
                });
                }
            }
        };

        var distance_warning_screen = {
            type: jsPsychHtmlButtonResponse,
            stimulus: function() {
                const chinrestData = jsPsych.data.get().filter({ trial_type: 'virtual-chinrest' }).last(1).values()[0];
                if (chinrestData && chinrestData.was_clamped) {
                return `
                    <p style="font-size: 24px; color: red;">⚠️ You appear to be sitting too far from the screen.</p>
                    <p style="font-size: 20px;">To ensure the image fits on screen, please move closer and recalibrate.</p>
                    <p style="font-size: 20px;">Press <b>Recalibrate</b> to redo the calibration process.</p>
                `;
                } else {
                return `<p style="font-size: 22px;">Calibration complete. Press Continue to proceed.</p>`;
                }
            },
            choices: function() {
                const chinrestData = jsPsych.data.get().filter({ trial_type: 'virtual-chinrest' }).last(1).values()[0];
                return chinrestData && chinrestData.was_clamped ? ['Recalibrate'] : ['Continue'];
            }
        };

        // zoom detection function
        function detectZoomLevel() {
            return window.devicePixelRatio || 1;
        }

        var distance_check_loop = {
            timeline: [
                virtual_chinrest,
                {
                    type: jsPsychHtmlKeyboardResponse,
                    stimulus: "<p>Calibrating image size...</p>",
                    choices: "NO_KEYS",
                    trial_duration: 100,
                    },
                distance_warning_screen
            ],
            loop_function: function() {
                const chinrestData = jsPsych.data.get().filter({ trial_type: 'virtual-chinrest' }).last(1).values()[0];
                return chinrestData && chinrestData.was_clamped;
            }
            };



        var baselineZoom = 1.0;

        var store_zoom_level = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: "<p>Checking browser zoom level...</p>",
            choices: "NO_KEYS",
            trial_duration: 100,
            on_start: function() {
                baselineZoom = detectZoomLevel();
                console.log("✅ Baseline Zoom Level:", baselineZoom);
            }
        };

 
        
        // show consent form before the experiment starts
        var consent_form = {
            type: jsPsychHtmlButtonResponse,
            stimulus: '<p style="font-size:36px";">Study consent form</p>' +
            '<p align="left"; style="font-size:20px";">The School of Psychological Sciences at Tel-Aviv University would like to thank you for participating in an important scientific study in the group-breaking field of cognitive psychology.</p>' + 
            '<p align="left"; style="font-size:20px";">The results collected from your response will greatly contribute to scientific progress and human development.</p>' +
            '<p align="left"; style="font-size:20px";">Tel-Aviv University supports the protection of participants in research. The following will provide you with information about the experiment that will help you in deciding whether or not you wish to participate.</p>' +
            '<p align="left"; style="font-size:20px";">If you agree to participate, please be aware that you are free to withdraw at any point throughout the duration of the experiment.</p>' +
            '<p align="left"; style="font-size:20px";">In this study you will be asked  to watch a video clip while trying to notice and report an unexpected change and answering questions about details of the clip.</p>' +
            '<p align="left"; style="font-size:20px";">All information you provide will remain confidential and will not be associated with your name.</p>' +
            '<p align="left"; style="font-size:20px";">Your participation in this study will take approximately 10 minutes.</p>' +
            '<p align="left"; style="font-size:20px";">If you have any further questions concerning this study please feel free to contact us through email: Liad Mudrik mudriklab2@gmail.com.</p>' +
            '<p align="left"; style="font-size:20px";">Your participation is solicited, yet strictly voluntary.</p>' +
            '<p align="left"; style="font-size:20px";">Please indicate below that you understand your rights and agree to participate in the experiment or exit the experiment if you do not wish to participate.</p>',
            choices: ['Consent']
        };

        // preload the masks
        const preload_masks = {
            type: jsPsychPreload,
            images: Array.from({length: 30}, (_, i) =>
                `stimuli/masks/mask_${String(i + 1).padStart(2, '0')}.jpg`
            )
        };


     
        // get participant info
        var participant_info_questions = {
            type: jsPsychSurveyHtmlForm,
            html: `
                <p><label>Prolific ID: <input name="ProlificID" required></label></p>
                <p><label>Age: <input name="age" type="number" required></label></p>
                <p><label>Gender:
                    <select name="gender" required>
                        <option value="" disabled selected>Select gender</option>
                        <option value="Female">Female</option>
                        <option value="Male">Male</option>
                        <option value="Other">Other</option>
                        <option value="Prefer not to answer">Prefer not to answer</option>
                    </select>
                </label></p>
                <p><label>Handedness:
                    <select name="handedness" required>
                        <option value="" disabled selected>Select handedness</option>
                        <option value="Left">Left</option>
                        <option value="Right">Right</option>
                    </select>
                </label></p>
            `,
            button_label: "Submit"
        };



        
        // Instructions and metadata collection
        var instructions = {
        type : jsPsychInstructions,
        pages : [
            '<p style ="font-size=24px">Welcome to our experiment!</p>' +
            '<p style ="font-size=26px">Press "Next" to read its instructions</p>',
            '<p style ="font-size=26px">In this experiment, you will see pairs of images presented one after the other.</p>' +
            '<p style ="font-size=26px">Your task is to rate how similar the two images are on a scale from "Very Different" to "Very Similar".</p>',
            '<p style ="font-size=26px">Please make sure to pay close attention to the images as they appear on the screen.</p>',
            '<p style ="font-size=26px">After viewing both images in a pair, use the slider to provide your similarity rating.</p>' + 
            '<p style ="font-size=26px">Press "Next" when you are ready to begin the experiment.</p>'
        ],
        show_clickable_nav : true
        };

        
        // move to full screen mode
        var show_full_screen = {
            type: jsPsychFullscreen,
            message: '<p>The experiment will switch to full screen mode when you press the button below</p>' +
            '<p>Do not exit full screen mode until the end of the experiment</p>',
            fullscreen_mode: true
        };

        //webgazer setgazer listener and begin
        //do i need to name th webgazer.js file something before calling it?
        //to save and restore training data from browswer between sessions use local forge.
        var camera_instructions = {
        type: jsPsychHtmlButtonResponse,
        stimulus: `
          <p>In order to participate you must allow the experiment to use your camera.</p>
          <p>You will be prompted to do this on the next screen.</p>
          <p>If you do not wish to allow use of your camera, you cannot participate in this experiment.<p>
          <p>It may take up to 30 seconds for the camera to initialize after you give permission.</p>
        `,
        choices: ['Got it'],
        }

        var init_camera = {
            type: jsPsychWebgazerInitCamera
        }

        var calibration_instructions = {
            type: jsPsychHtmlButtonResponse,
            stimulus: `
            <p>Now you'll calibrate the eye tracking, so that the software can use the image of your eyes to predict where you are looking.</p>
            <p>You'll see a series of dots appear on the screen. Look at each dot and click on it.</p>
            `,
            choices: ['Got it'],
        }


        // clibration documenting: https://www.jspsych.org/latest/plugins/webgazer-calibrate/
        var calibration = {
            type: jsPsychWebgazerCalibrate,
            // numbers calibrated are percent of pixels from [left,top]
            on_start: function() {
                calibrationCountThisBlock++;
            },
            calibration_points: [
            [25,25],[75,25],[50,50],[25,75],[75,75]
            ],
            repetitions_per_point: 2,
            randomize_calibration_order: true
        }

        var validation_instructions = {
            type: jsPsychHtmlButtonResponse,
            stimulus: `
            <p>Now we'll measure the accuracy of the calibration.</p>
            <p>Look at each dot as it appears on the screen.</p>
            <p style="font-weight: bold;">You do not need to click on the dots this time.</p>
            `,
            choices: ['Got it'],
            post_trial_gap: 1000
        }

        // validation documentation: https://www.jspsych.org/latest/plugins/webgazer-validate/
        var validation = {
            type: jsPsychWebgazerValidate,
            validation_points: [
            [25,25],[75,25],[50,50],[25,75],[75,75]
            ],
            roi_radius: 200,
            time_to_saccade: 1000,
            validation_duration: 2000,
            data: {
            task: 'validate'
            }
        }

        var recalibrate_instructions = {
            type: jsPsychHtmlButtonResponse,
            stimulus: `
            <p>The accuracy of the calibration is a little lower than we'd like.</p>
            <p>Let's try calibrating one more time.</p>
            <p>On the next screen, look at the dots and click on them.<p>
            `,
            choices: ['OK'],
        }

        var calibration_done = {
            type: jsPsychHtmlButtonResponse,
            stimulus: `
            <p>Great, we're done with calibration!</p>
            `,
            choices: ['OK']
        }

        var validation_done = {
            type: jsPsychHtmlButtonResponse,
            stimulus: `
                <p>✅ Calibration complete!</p>
                <p>Your eye tracking accuracy is sufficient.</p>
                <p>Click the button below to continue to the experiment.</p>
            `,
            choices: ['Continue']
        };

        
        var calibration_loop = {
            timeline: [
                // conditional recalibration instructions - only from the 2nd loop
                {
                    timeline: [recalibrate_instructions],
                    conditional_function: function() {
                        // Only show recalibrate_instructions if this is NOT the first calibration
                        return calibrationCountThisBlock > 0;  
                    }
                },
                calibration,                    // shows dot-click calibration
                calibration_done,              // "We're done" screen
                validation_instructions,       // tells them not to click
                validation,                   // gaze-only validation
            ],
            loop_function: function() {
                // ⛳ This function runs after each full cycle of the above timeline
                const valData = jsPsych.data.get().filter({ task: 'validate' }).last(1).values()[0];
                
                // ✅ Repeat the loop if ANY point is under 50% accuracy
                return valData && valData.percent_in_roi
                    ? valData.percent_in_roi.some(p => p < 10)
                    : true; // just in case data is missing
            }
        };





        var begin = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: `<p>The next screen will show an image to demonstrate adding the webgazer extension to a trial.</p>
            <p>Just look at the image while eye tracking data is collected. The trial will end automatically.</p>
            <p>Press any key to start.</p>
            `
        }
        

        var trial = {
            type: jsPsychImageKeyboardResponse,
            stimulus: 'stimuli/masks/mask_01.jpg',
            choices: "NO_KEYS",
            trial_duration: 2000,
            extensions: [
                {
                    type: jsPsychExtensionWebgazer, 
                    params: {targets: ['#jspsych-image-keyboard-response-stimulus']}
                }
            ],
            on_start: function() {
                const dot = document.getElementById('gaze-dot');
                webgazer.setGazeListener(function(data) {
                    if (!data || typeof data.x !== 'number' || typeof data.y !== 'number') {
                        dot.style.display = 'none';
                        return;
                    }
                    dot.style.left = `${data.x - 7.5}px`;
                    dot.style.top = `${data.y - 7.5}px`;
                    dot.style.display = 'block';
                });
            },
            on_finish: function() {
            webgazer.clearGazeListener();
            const dot = document.getElementById('gaze-dot');
            if (dot) {
                dot.style.display = 'none';
            }
        }
    };


        var show_data = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function() {
            var trial_data = jsPsych.data.getLastTrialData().values();
            var trial_json = JSON.stringify(trial_data, null, 2);
            return `<p style="margin-bottom:0px;"><strong>Trial data:</strong></p>
                <pre style="margin-top:0px;text-align:left;">${trial_json}</pre>`;
            },
            choices: "NO_KEYS"
        };


        // more in depth instructions for the experiment
        const before_exp_screen = {
        type: jsPsychHtmlButtonResponse,
        stimulus: `
            <p style="font-size:30px;">We are ready to start the experiment!</p>
            <p style="font-size:23px;">In this experiment, you will view pairs of images presented one after the other.</p>
            <p style="font-size:23px;">Your task is to evaluate the similarity between the two images and provide a rating on a slider.</p>
            <p style="font-size:23px;">Pay close attention to each image and try to focus on the details before making your decision.</p>
            <p style="font-size:23px;">Press <b>"Start"</b> to begin the experiment.</p>`,
        choices: ['Start']
        };


        const pre_calibration_message = {
            type: jsPsychHtmlButtonResponse,
            stimulus: `
                <p style="font-size: 26px;">Before the next block begins, we need to recalibrate the eye tracker.</p>
                <p style="font-size: 22px;">This helps ensure your gaze data is accurate.</p>
                <p style="font-size: 22px;">Please follow the instructions on the next screens and look directly at the dots.</p>
            `,
            choices: ['Continue']
        };



        //recheck zoom level before block
        var check_zoom_loop = {
            timeline: [
                {
                    type: jsPsychHtmlButtonResponse,
                    stimulus: function() {
                        const currentZoom = detectZoomLevel();
                        const deviation = Math.abs(currentZoom - baselineZoom);
                        const currentPercent = Math.round(currentZoom * 100);
                        const baselinePercent = Math.round(baselineZoom * 100);

                        // check if zoom is still ok
                        if (deviation > 0.05) {
                            console.warn("⚠️ Zoom changed! Current:", currentZoom, "Baseline:", baselineZoom);
                            return `
                                <p style="color:red; font-size:24px;">
                                    ⚠️ Your browser zoom level has changed since the calibration.<br><br>
                                    Please adjust your zoom (Ctrl + or - / Cmd + or -) to match the calibrated value.
                                </p>
                                <p style="font-size:20px;">
                                    Expected zoom: <b>${baselinePercent}%</b><br>
                                    Current zoom: <b>${currentPercent}%</b>
                                </p>
                                <p style="font-size:18px; color:#666;">
                                    Click the button once you've adjusted your zoom to match.
                                </p>`;
                        } else {
                            console.log("✅ Zoom OK:", currentZoom);
                            return `<p style="font-size:24px;">Zoom level OK (${currentPercent}%). Continuing the experiment...</p>`;
                        }
                    },
                    choices: ['I’ve adjusted my zoom — continue'],
                }
            ],
            loop_function: function() {
                const currentZoom = detectZoomLevel();
                const deviation = Math.abs(currentZoom - baselineZoom);
                return deviation > 0.05; // keep looping until matched
            }
        };




        //let lastFixationValid = false; // put this once, at the top of your script (outside the function)

/*function getFixationValidationLoop(pixelsPerDegree, toleranceDegrees = 1) {
  const radiusPx = pixelsPerDegree * toleranceDegrees;

  return {
    timeline: [
      // Fixation cross
      {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: function () {
          let size = 26 * pixelsPerDegree;
          return `
            <div style="display: flex; justify-content: center; align-items: center; height: 100vh;">
              <div style="font-size: ${size * 0.8}px;">+</div>
            </div>`;
        },
        choices: "NO_KEYS",
        trial_duration: 500,
        extensions: [{
          type: jsPsychExtensionWebgazer,
          params: { targets: ['body'] }
        }],
        on_start: function() {
            if (webgazer && webgazer.resume) {
                webgazer.resume();
                console.log("🔄 WebGazer resumed");
            }
        },

        on_finish: function(data) {
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;
          const gaze = webgazer.getCurrentPrediction();

          let valid = false;

          if (gaze && gaze.x != null && gaze.y != null) {
            const dx = gaze.x - centerX;
            const dy = gaze.y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            valid = distance <= radiusPx;
            console.log("📏 Distance:", distance.toFixed(2), "Valid?", valid);
          } else {
            console.warn("⚠️ Gaze data not available");
          }

          data.fixation_valid = valid;
          lastFixationValid = valid;
        }
      },

      // Retry screen if fixation invalid
      {
        type: jsPsychHtmlButtonResponse,
        stimulus: `
          <p style="font-size: 24px; color: red;">You were not fixated on the center.</p>
          <p>Please look directly at the cross and try again.</p>
        `,
        choices: ['Try again'],
        conditional_function: function() {
          return lastFixationValid === false;
        }
      }
    ],

    loop_function: function() {
      console.log("🧪 Loop check — was fixation valid?", lastFixationValid);
      return lastFixationValid === false;
    }
  };
}*/


const smartFixationCore = {
  type: jsPsychImageKeyboardResponse,
  stimulus: 'stimuli/fixation_cross.png',
  stimulus_height: imageHeight,
  data: { trial_id: 'fixation' },
  choices: "NO_KEYS",
  trial_duration: null, // we manually end the trial
  on_load: function() {
    const buffer = [];
    const radiusPx = pixelsPerDegree * 1; // or use a fixed large px value for debugging
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    const startTime = performance.now();

    const interval = setInterval(async () => {
      const now = performance.now();
      const gaze = await webgazer.getCurrentPrediction();

      if (gaze && gaze.x != null && gaze.y != null) {
        buffer.push({ x: gaze.x, y: gaze.y, t: now });

        // Keep last 500ms of gaze
        const recent = buffer.filter(pt => now - pt.t <= 500);

        const inside = recent.filter(pt => {
          const dx = pt.x - centerX;
          const dy = pt.y - centerY;
          return Math.sqrt(dx * dx + dy * dy) <= radiusPx;
        });

        const percent = (inside.length / recent.length) * 100;
        console.log(`📊 Gaze buffer: ${percent.toFixed(1)}% in ROI`);

        if (recent.length >= 6 && percent >= 50) {
          clearInterval(interval);
          jsPsych.finishTrial({ fixation_success: true });
        }
      }

      // Timeout fallback
      if (now - startTime > 10000) {
        clearInterval(interval);
        console.warn("⏱ Fixation failed: 10s timeout");
        jsPsych.finishTrial(); // fixation_success will be set in on_finish
      }
    }, 50);
  },

  on_finish: function(data) {
    // If fixation_success was not set (i.e. from timeout), set it to false
    if (typeof data.fixation_success === 'undefined') {
      data.fixation_success = false;
    }
  }
};



const smartFixationRetry = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: `
    <p style="font-size: 24px;">Please center your gaze on the cross.</p>
    <p id="countdown-text" style="font-size: 18px;">Returning in 10 seconds...</p>`,
  choices: "NO_KEYS",
  trial_duration: 10000,
  on_load: function() {
    let seconds = 10;
    const txt = document.getElementById("countdown-text");
    const interval = setInterval(() => {
      seconds--;
      if (txt) txt.innerText = `Returning in ${seconds} seconds...`;
      if (seconds <= 0) clearInterval(interval);
    }, 1000);
  }
};

        
function getSmartFixationTrial() {
  return {
    timeline: [
      smartFixationCore,  // actual gaze buffer logic
      {
        timeline: [smartFixationRetry],
        conditional_function: function() {
          const last = jsPsych.data.get().filter({ trial_type: 'html-keyboard-response' }).last(1).values()[0];
          console.log("🧪 Retry condition check — fixation_success:", last?.fixation_success);
          return last && last.fixation_success === false;
        }
      }
    ],
    loop_function: function() {
  const last = jsPsych.data.get().filter({ trial_id: 'fixation' }).last(1).values()[0];
  console.log("🔁 Loop check — fixation_success:", last?.fixation_success);
  return last && last.fixation_success === false;
}


  };
}




        

        var sequential_trial = {
            timeline: [
                // 1. Smart fixation with gaze buffer logic
                    getSmartFixationTrial(pixelsPerDegree, 40),

                // Image 1
                {
                    type: jsPsychHtmlKeyboardResponse,
                    stimulus: function () {
                        const img = jsPsych.timelineVariable('image1');
                        return `
                        <div style="display: flex; justify-content: center; align-items: center; height: 100vh;">
                            <img src="${img}" style="height: ${26 * pixelsPerDegree}px; max-height: 100vh; display: block;" />
                        </div>`;
                    },
                    choices: "NO_KEYS",
                    trial_duration: 1000,
                    extensions: [{
                        type: jsPsychExtensionWebgazer,
                        params: {
                            targets: ['img']
                        }
                    }]
                },

                // Mask after image 1
                {
                    type: jsPsychHtmlKeyboardResponse,
                    stimulus: function () {
                        const idx = Math.floor(Math.random() * 30) + 1;
                        const maskPath = `stimuli/masks/mask_${String(idx).padStart(2, '0')}.jpg`;
                        return `
                        <div style="display: flex; justify-content: center; align-items: center; height: 100vh;">
                            <img src="${maskPath}" style="height: ${26 * pixelsPerDegree}px; max-height: 100vh; display: block;" />
                        </div>`;
                    },
                    choices: "NO_KEYS",
                    trial_duration: 500,
                    extensions: [{
                        type: jsPsychExtensionWebgazer,
                        params: {
                            targets: ['img']
                        }
                    }]
                },

                // Fixation before image 2
                {
                    type: jsPsychImageKeyboardResponse,
                    stimulus: 'stimuli/fixation_cross.png',
                    stimulus_height: imageHeight,
                    choices: "NO_KEYS",
                    trial_duration: 500,
                    extensions: [{
                        type: jsPsychExtensionWebgazer,
                        params: {
                            targets: ['#jspsych-html-keyboard-response-stimulus']
                        }
                    }]
                },

        // Image 2
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function () {
                const img = jsPsych.timelineVariable('image2');
                return `
                <div style="display: flex; justify-content: center; align-items: center; height: 100vh;">
                    <img src="${img}" style="height: ${26 * pixelsPerDegree}px; max-height: 100vh; display: block;" />
                </div>`;
            },
            choices: "NO_KEYS",
            trial_duration: 1000,
            extensions: [{
                type: jsPsychExtensionWebgazer,
                params: {
                    targets: ['img']
                }
            }]
        },

        // Mask after Image 2
        {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: function () {
                const idx = Math.floor(Math.random() * 30) + 1;
                const maskPath = `stimuli/masks/mask_${String(idx).padStart(2, '0')}.jpg`;
                return `
                <div style="display: flex; justify-content: center; align-items: center; height: 100vh;">
                    <img src="${maskPath}" style="height: ${26 * pixelsPerDegree}px; max-height: 100vh; display: block;" />
                </div>`;
            },
            choices: "NO_KEYS",
            trial_duration: 500,
            extensions: [{
                type: jsPsychExtensionWebgazer,
                params: {
                    targets: ['img']
                }
            }]
        },

        // Similarity rating
        {
            type: jsPsychSurveyMultiChoice,
            questions: [
                {
                    prompt: "",
                    name: "similarity",
                    options: ["1", "2", "3", "4", "5"],
                    required: true,
                    horizontal: true
                }
            ],
            on_load: function () {
                const container = document.querySelector('.jspsych-content');

                // Add top prompt
                const promptText = document.createElement('div');
                promptText.innerHTML = `
                <p style="font-size: 20px; text-align: center;">
                    Please rate the similarity of the two images using the following scale:<br>
                </p>`;
                container.insertBefore(promptText, container.firstChild);

                // Style the question block horizontally
                const questionWrapper = document.querySelector('.jspsych-survey-multi-choice-question');
                questionWrapper.style.display = 'flex';
                questionWrapper.style.justifyContent = 'center';
                questionWrapper.style.alignItems = 'center';
                questionWrapper.style.gap = '12px';
                questionWrapper.style.margin = '10px 0';

                // Create side labels
                const leftLabel = document.createElement('div');
                const rightLabel = document.createElement('div');
                leftLabel.innerText = "Not at all similar";
                rightLabel.innerText = "Extremely similar";
                [leftLabel, rightLabel].forEach(label => {
                    label.style.fontSize = '14px';
                    label.style.width = '120px';
                });

                // Insert side labels
                questionWrapper.prepend(leftLabel);
                questionWrapper.appendChild(rightLabel);

                // Style each option (number above button)
                const options = questionWrapper.querySelectorAll('.jspsych-survey-multi-choice-option');
                options.forEach(option => {
                    const label = option.querySelector('label');
                    const input = option.querySelector('input[type="radio"]');
                    option.innerHTML = '';

                    option.style.display = 'flex';
                    option.style.flexDirection = 'column';
                    option.style.alignItems = 'center';
                    option.style.margin = '0 5px';

                    label.style.marginBottom = '4px';
                    option.appendChild(label);
                    option.appendChild(input);
                });

                // Hide red asterisk if exists
                const requiredMark = document.querySelector('.jspsych-survey-multi-choice-required');
                if (requiredMark) {
                    requiredMark.style.display = 'none';
                }
            }
        }
    ],
    timeline_variables: [], // fill in your image1/image2 combinations here
    randomize_order: true
};


        // ====== Resets calibration counter to 0 ======
        const reset_calibration_counter = {
            type: jsPsychCallFunction,
            func: function() {
                calibrationCountThisBlock = 0;
            }
        };


        // ====== Generate image pairs and set the pairs in a random order ======
        const ordered_pairs = [];
        for (let i = 1; i <= 400; i += 2) {
            const image1 = `stimuli/pictures/image_${String(i).padStart(3, '0')}.jpg`;
            const image2 = `stimuli/pictures/image_${String(i + 1).padStart(3, '0')}.jpg`;
            ordered_pairs.push({ image1, image2 });
        }
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        shuffle(ordered_pairs);



        // ====== Divide into 4 ordered blocks of 50 trials ======
        const blocks = [];
        const trialsPerBlock = 3; // how many trials in each block - should be 50 (1 for testing)
        
        for (let i = 0; i < 4; i++) {
            const block_pairs = ordered_pairs.slice(i * trialsPerBlock, (i + 1) * trialsPerBlock);
            const block_images = block_pairs.flatMap(pair => [pair.image1, pair.image2]);

            const preload_block_images = {
                type: jsPsychPreload,
                images: block_images
            };

            const block = {
                timeline: [
                    preload_block_images,  // ✅ Load only images for this block
                    check_zoom_loop,
                    {
                        timeline: sequential_trial.timeline,
                        timeline_variables: block_pairs,
                        on_start: function() {
                            calibrationCountThisBlock = 0;
                            const zoomPercent = Math.round(detectZoomLevel() * 100);
                            jsPsych.data.addProperties({
                                [`zoom_at_block_${i + 1}_percent`]: zoomPercent,
                            });
                        },
                        on_finish: function() {
                            jsPsych.data.addProperties({
                                [`calibration_count_at_block_${i + 1}`]: calibrationCountThisBlock
                            }); 
                        }
                    },
                    ...(i < 3 ? [
                        {
                        type: jsPsychHtmlButtonResponse,
                        stimulus: `<p style="font-size:24px;">Block ${i + 1} complete.<br>
                                    Please rest. When you are ready, click <b>Continue</b>.</p>`,
                        choices: ['Continue']
                        }
                    ] : [])
                ]
            };

            blocks.push(block);
        }



        ////////////////////////
        // Experiment ending  // 
        ////////////////////////

        // before ending the experiment, exit full screen mode
        var exit_full_screen = {
            type: jsPsychFullscreen,
            fullscreen_mode: false,
            delay_after: 5
        };
        
        // the ending screen of the experiment
        var finish_exp = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: '<p style="font-size=42px">Thank you for participating!</p>' +
            '<p style="font-size=47x"><b>Don\'t close the window yet!</b></p>' +
            '<p style="font-size=42px">Press any key to finish the experiment</p>'
        };
        
        
        ///////////////////
        // Functions     // 
        ///////////////////
        
        const timeline_start = [
            
            // ✅ Virtual chinrest: distance estimation & zoom validation
            distance_check_loop,

            // ✅ Consent + participant info
            consent_form,
            preload_masks,
            participant_info_questions,

            // ✅ Instructions before eye tracking begins
            instructions,
            show_full_screen,
            
            
            // ✅ Camera and WebGazer setup
            camera_instructions,
            init_camera,

            // ✅ Calibration loop (with validation and optional retry instructions)
            calibration_loop,

            // ✅ Calibration was validated successfuly, thus finishing the calibration loop
            validation_done,
            // ✅ Transition screen before starting the main experiment
            before_exp_screen,    
            
            // ✅ 1st Block
            blocks[0],

            pre_calibration_message,
            reset_calibration_counter,
            calibration_loop,
            validation_done,
            
            // ✅ 2nd Block
            blocks[1],

            pre_calibration_message,
            reset_calibration_counter,
            calibration_loop,
            validation_done,

            // ✅ 3rd Block            
            blocks[2],

            pre_calibration_message,
            reset_calibration_counter,
            calibration_loop,
            validation_done,

            // ✅ 4th Block            
            blocks[3],

            // ✅ Exit fullscreen and debrief/thank-you screen
            exit_full_screen,
            finish_exp
        ];


        jatos.onLoad(() => {
            console.log("Experiment is starting");
            jsPsych.run(timeline_start);
        });



    </script>

</html>